package org.puremvc.as3.utilities.routes {	/**	 * Handles the parsing of the Routes; extracts and injects data into the	 * strings defining the Route. The routes themselves checks if the 	 * current address matches it.	 * 	 * Every route defined as a constant in the specified ApplicationRoutes 	 * class would create one of these.	 * 	 * TODO Would be cool with a validation of the routes, ex. you can define a 	 * 		route only with numbers (maybe "/page/{id}/{num:\d+}/" which would 	 * 		only allow "num" to be numbers, or "/page/{page:a|b|c}/" which would	 * 		be errored if "page" is not "a", "b" or "c")  	 * 	 * @author Robert Sköld, robert(at)publicclass.se	 * @see #extractData	 * @see #injectData	 */	public class Route {				private static const REGEXP_REPLACE_KEYS : RegExp = /{([^}]+?)(?:=([^}]+))?}\//g;		private var _keys : Array;		private var _filter : RegExp;		private var _defaults : Array;		private var _cache : Array;		private var _location : String;		private var _injectionData : Object;		private var _defaultData : Object;		public function Route( location : String ) {			_keys = new Array();			_defaults = new Array();			_defaultData = new Object();			_cache = new Array();			_location = location;			var filter : String = _location.replace( REGEXP_REPLACE_KEYS , replaceKeys );			_filter = new RegExp( "^" + filter.replace( /\//g , "\\/" ) + "$" , "ig" );//			Debug.trace( "Created route: " , _filter , StringUtil.formatInline( _keys ) , StringUtil.formatInline( _defaults ) , StringUtil.formatInline( _defaultData ) );		}		/**		 * Fetches the keys from the routes.		 * @see #extractData	Used by extractData		 */		private function replaceKeys() : String {			var pos : uint = _keys.push( arguments[1] );			if( arguments[2] != "" ) {				_defaults[ pos ] = arguments[2];				_defaultData[ arguments[1] ] = arguments[2];				return "([^/]+)?/?"; 			}			return "([^/]+)/";		}				/**		 * The original location of the route. The string		 * that's defined in the ApplicationRoutes class.		 */		public function get location() : String {			return _location;		}				/**		 * The default data object extracted from the route location.		 */		public function get defaultData() : Object {			return _defaultData;		}				/**		 * Based on the filter created when parsing the route		 * we're returning the data of the current state ordered		 * by the keys defined in the route.		 * 		 * The resulting data is cached for each state 		 * to avoid executing the expression every time.		 * 		 * @example		 * 		 * <pre>		 * Route:						Filter:						State:			Results:		 * /hello/{world}/				/hello/([^/]+)/				/hello/123/		{ world: 123 }		 * /{section}/{id}/				/([^/]+)/([^/]+)/			/page/1/		{ section: "page" , id: 1 }		 * /{section}/{id=1}/			/([^/]+)/([^/]+)?/?			/page/			{ section: "page" , id: 1 }		 * Invalid route: 		 * /{section}/{id=1}/{type}/	/([^/]+)/([^/]+)?/?			/page/1/embed	{ section: "page" , id: 1 , type: "embed" } (a Route may not define required data after optional data) 		 * </pre>		 */		public function extractData( from : String ) : Object {			if( _cache[ from ] )				return _cache[ from ]; 			_filter.lastIndex = 0;			var md : Object = _filter.exec( from );			var data : Object = {};			if( md ) {				var value : String;				for( var i : int = 1; i <= _keys.length; i++ ) {					value = md[ i ];					if( value == null && _defaults[ i ] != null ) 						value = _defaults[ i ];					data[ _keys[ int( i - 1 ) ] ] = value;				}			}//			Debug.trace( this , from , StringUtil.formatInline( data ) );			_cache[ from ] = data;			if( !md ) return data;			return data;		}				/**		 * The opposite of extractData, takes an object and		 * changes the keys in the stateName into the keys 		 * of the data. 		 */		public function injectData( data : Object ) : String {			if( _keys.length == 0 ) 				return _location;			_injectionData = merge( _defaultData , data );			try {				return _location.replace( REGEXP_REPLACE_KEYS , replaceData );			} catch( e : Error ) {				trace( e , this );			}			return null;		}				private function replaceData() : String {			var key : String = arguments[1];			if( !(key in _injectionData) ) 				throw new Error( "Key (" + key + ") does not exist in the data. Please double check the route." );			return _injectionData[ key ] + "/"; // Add the slash as the replace includes it...		}				/**		 * Checks if the state matches this route.		 * 		 * NOTE The results of these is cached in the RouteMachine.		 * 		 * @see #extractData	How the filter is used.		 */		public function isLocation( state : String ) : Boolean {			_filter.lastIndex = 0;			return _filter.exec( state ) != null;		}				private function merge( obj1 : Object , obj2 : Object ) : Object {			var obj : Object = new Object( );			var key : String;			for( key in obj1 ) obj[ key ] = obj1[ key ];			for( key in obj2 ) obj[ key ] = obj2[ key ];			return obj;		}				public function toString() : String {			return "[Route keys:" + _keys.join( "," ) + " filter:" + _filter + " state:" + _location + "]";		}	}}
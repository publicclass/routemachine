package org.puremvc.as3.utilities.routes {	import com.asual.swfaddress.SWFAddress;	import com.asual.swfaddress.SWFAddressEvent;	import org.puremvc.as3.interfaces.INotification;	import org.puremvc.as3.patterns.mediator.Mediator;	import flash.utils.describeType;	/**	 * Controls the applications state based on "routes".	 * 	 * Also show's the current route using SWFAddress. 	 * 	 * TODO The SWFAddress part should be extracted into a separate Proxy instead.	 * 	 * @see Route					Handles the parsing of the route strings.	 * @see ApplicationRoutes		Where the routes are defined.	 * 	 * @author Robert Sköld, robert(at)publicclass.se	 */	public class RouteMachine extends Mediator {		public static const NAME 		: String = "RouteMediator";			/**		 * Called to change the current route (a.k.a View state)		 * 		 * @example		 * 		 * If we're at route PAGE_A ("/page/a") and want to go		 * to route PAGE_B ("/page/b") we have a route called 		 * PAGE ("/page/{name}") which will be used for both.		 * 		 * In PAGE_A we press a link to PAGE_B which calls:		 * 		 * <code>sendNotification( RouteMachine.GOTO , { name: "b" } , ApplicationRoutes.PAGE );</code>		 * 		 * 		 * 		 */		public static const GOTO 		: String = NAME + "/note/goto";		public static const INTERRUPT	: String = NAME + "/note/interrupt";		public static const CANCEL		: String = NAME + "/note/cancel";		public static const CONTINUE	: String = NAME + "/note/continue";				public static const ENTERING 	: String = NAME + "/note/entering";		public static const EXITING 	: String = NAME + "/note/exiting";		public static const CHANGED 	: String = NAME + "/note/changed";		private var _currentRoute : Route;		private var _currentLocation : String;		private var _cached : Array = new Array( );				private var _inTransition : Boolean;		private var _interrupted : Boolean;		private var _skipEnter : Boolean;		private var _skipExit : Boolean;		private var _continueData : Object;		private var _continueRoute : Route;		private var _initialRoute : String;		public function RouteMachine( routeClass : Class , initialRoute : String ) {			_initialRoute = initialRoute;			super( NAME, extractRoutes( routeClass ) );		}		private function extractRoutes( routeClass : Class ) : Array {			var desc : XML = describeType( routeClass );			var routes : Array = [];			for each( var state : XML in desc.constant )				routes.push( new Route( routeClass[state.@name] ) );			return routes;		}		override public function listNotificationInterests() : Array {			return [ RouteMachine.GOTO , RouteMachine.INTERRUPT , RouteMachine.CANCEL , RouteMachine.CONTINUE ];		}		override public function handleNotification(notification : INotification) : void {			switch( notification.getName( ) ) {				case RouteMachine.GOTO:					if( _inTransition ) return;					var route : Route = getMatchingRoute( notification.getType( ) );					var data : Object = notification.getBody() || route.defaultData;					trace( "GOTO " + notification.getType() , _continueRoute );					transitionTo( route , data );					break;				case RouteMachine.INTERRUPT:					trace( "INTERRUPT" );					_interrupted = true;					break;				case RouteMachine.CANCEL:					trace( "CANCEL" );					reset();					// TODO Should this be going back to it's previous state, only on exit? or also on enter?//					if( _skipExit && !_skipEnter )//						sendNotification( RouteMachine.GOTO, body, type)					break;				case RouteMachine.CONTINUE:					trace( "CONTINUE " + ( ( _skipEnter ) ? "(from enter)" : ( _skipExit ) ? "(from exit)" : "error" ) , _continueRoute );					if( !_inTransition ) 						throw new Error( "Need to cancel before continuing. Use GOTO instead." );					transitionTo( _continueRoute, _continueData );					break;			}		}				/**		 * Makes the RouteMachine as good as new. And now the GOTO may be called again...		 */		private function reset() : void {			_interrupted = false;			_continueRoute = null;			_continueData = null;			_skipEnter = _skipExit = false;			_inTransition = false;		}		override public function onRegister() : void {			SWFAddress.addEventListener( SWFAddressEvent.CHANGE, onAddressChange );		}		protected function transitionTo( nextRoute : Route , data : Object ) : void {			if( !nextRoute )				return;			//			Debug.trace( nextRoute , StringUtil.formatInline( data ) );						var nextLocation : String = fixLocation( nextRoute.injectData( data ) );						// Same location means it's the same, so skip it.			if( _currentLocation && _currentLocation == nextLocation ) {				reset(); // Allow it to try again...				return;			}						// Clear the interrupt flag			_interrupted = false;			_inTransition = true;							// Exit the current  			trace( "EXITING " + nextLocation ); 			if( _currentRoute != null && !_skipExit )				facade.notifyObservers( new RouteNotification( RouteMachine.EXITING , _currentRoute , _currentLocation , nextRoute , nextLocation , data ) );			_skipExit = true;						// Check to see whether the transition has been canceled			if( _interrupted ) {				trace( "INTERRUPTED (during exit)" );				_continueRoute = nextRoute;				_continueData = data;				return;			}						trace( "ENTERING " + nextLocation ); 			// Enter the next			if( !_skipEnter )				facade.notifyObservers( new RouteNotification( RouteMachine.ENTERING , _currentRoute , _currentLocation , nextRoute , nextLocation , data ) );			_skipEnter = true;						// Check to see whether the transition has been canceled			if( _interrupted ) {				trace( "INTERRUPTED (during enter)" );				_continueRoute = nextRoute;				_continueData = data;				return;			}						// Allow the route to be changed again.			reset();						// Update the address before we set the _currentLocation as it checks against it...			changeAddress( nextLocation );						// Save the current route			_currentRoute = nextRoute;			_currentLocation = nextLocation;						trace( "CHANGED " + nextLocation ); 						// Send the notification configured to be sent when this specific state becomes current 			facade.notifyObservers( new RouteNotification( RouteMachine.CHANGED, _currentRoute , _currentLocation , nextRoute , nextLocation , data ) );		}						protected function getMatchingRoute( location : String ) : Route {			if( _cached[ location ] ) return _cached[ location ];			for each( var route : Route in routes ) 				if( route.isLocation( location ) )					return _cached[ location ] = route;			return null;		}		protected function get routes() : Array {			return viewComponent as Array;		}				/**		 * Changes to the address from internally should not		 * invoke the onAddressChange event. Only external changes		 * should.		 * @private		 */		private function changeAddress( location : String ) : void {			trace( "From: " + _currentLocation , "To: " + location );			if( location == _currentLocation ) return;			SWFAddress.removeEventListener( SWFAddressEvent.CHANGE, onAddressChange );			SWFAddress.setValue( location );			SWFAddress.addEventListener( SWFAddressEvent.CHANGE, onAddressChange );		}		private function onAddressChange(e : SWFAddressEvent) : void {						var location : String = fixLocation( e.value );			var route : Route = getMatchingRoute( location );						trace( "CHANGE ADDRESS" , route, location );						if( _inTransition )				changeAddress(location);										if( !route ) {				sendNotification( RouteMachine.GOTO, null, _initialRoute );				return; 			}			var data : Object = route.extractData( location );			sendNotification( RouteMachine.GOTO, data, route.location );		}				/**		 * Make sure it's a valid location (starting and ending with /)		 */		private function fixLocation( location : String ) : String {			if( location.substr( 0, 1 ) != "/") location = "/" + location;			if( location.substr( -1, 1 ) != "/") location += "/";			return location;		}	}}
package org.puremvc.as3.utilities.routes {	import org.puremvc.as3.interfaces.INotification;	import org.puremvc.as3.patterns.mediator.Mediator;	import flash.utils.describeType;	/**	 * Controls the applications state based on "routes".	 * 	 * @see Route					Handles the parsing of the route strings.	 * @see ApplicationRoutes		Where the routes are defined.	 * @see RoutedMediator			Convenience Mediator which avoids redundancy.	 * 	 * @author Robert Sköld, robert(at)publicclass.se	 */	public class RouteMachine extends Mediator {		public static const NAME 			: String = "RouteMachine";		public static const VERSION			: String = "1.0.0";				public static var DEBUG 			: Boolean = false;		public static var DEBUG_LOG			: Function = trace;		public static var DEBUG_ERROR		: Function = trace; 			/**		 * Called to change the current route (a.k.a View state)		 * 		 * @example		 * 		 * If we're at route PAGE_A ("/page/a") and want to go		 * to route PAGE_B ("/page/b") we have a route called 		 * PAGE ("/page/{name}") which will be used for both.		 * 		 * In PAGE_A we press a link to PAGE_B which calls:		 * 		 * <code>sendNotification( RouteMachine.GOTO , { name: "b" } , ApplicationRoutes.PAGE );</code>		 * 		 */		public static const GOTO 			: String = NAME + "/note/goto";				/**		 * Call this to "pause" the ongoing transition.		 * 		 * @example		 * 		 * <p><strong>How to use the <code>RouteMachine.INTERRUPT</code> and <code>RouteMachine.CONTINUE</code>.</strong></p>		 * 		 * <p>Assuming we're currently in <code>ApplicationRoute.CURRENT</code> and has called		 * <code>sendNotification( RouteMachine.GOTO , {} , ApplicationRoutes.NEXT );</code></p>		 * 		 * <p>This also assumes the of the <code>RoutedMediator</code>.</p>		 * 		 * <listing version="3.0"><pre>		 * override public function onExitingRoute( notification : RouteNotification ) : void {		 * 		switch( notification.fromRoute ) {		 * 			case ApplicationRoute.CURRENT:		 * 				currentView.addEventListener( Event.COMPLETE , onFadedOut );		 * 				currentView.fadeOut();		 * 				sendNotification( RouteMachine.INTERRUPT );		 * 				break;		 * 			// Handling of other routes here		 * } 		 * private function onFadedOut() : void {		 * 		currentView.removeEventListener( Event.COMPLETE , onFadedOut );		 * 		sendNotification( RouteMachine.CONTINUE );		 * }		 * </pre></listing>		 *  		 * @see RoutedMediator			 */		public static const INTERRUPT		: String = NAME + "/note/interrupt";				/**		 * Call this to abort a "paused" transition.		 * 		 * @example 		 * 		 * <p><strong>How to use the <code>RouteMachine.INTERRUPT</code> and <code>RouteMachine.CANCEL</code>.</strong></p>		 * 		 * <p>Assuming we're currently in <code>ApplicationRoute.PREVIOUS</code> and has called		 * <code>sendNotification( RouteMachine.GOTO , {} , ApplicationRoutes.CURRENT );</code></p>		 * 		 * <p>This also assumes the of the <code>RoutedMediator</code>.</p>		 * 		 * <listing version="3.0"><pre>		 * override public function onEnteringRoute( notification : RouteNotification ) : void {		 * 		switch( notification.toRoute ) {		 * 			case ApplicationRoute.CURRENT:		 * 				currentView.addEventListener( Event.COMPLETE , onContentLoaded );		 * 				currentView.addEventListener( IOErrorEvent.IO_ERROR , onContentLoadError );		 * 				currentView.loadContent();		 * 				sendNotification( RouteMachine.INTERRUPT );		 * 				break;		 * 			// Handling of other routes here		 * } 		 * private function onContentLoaded() : void {		 * 		currentView.removeEventListener( Event.COMPLETE , onContentLoaded );		 * 		currentView.removeEventListener( IOErrorEvent.IO_ERROR , onContentLoadError );		 * 		sendNotification( RouteMachine.CONTINUE );		 * }		 * private function onContentLoadError() : void {		 * 		currentView.removeEventListener( Event.COMPLETE , onContentLoaded );		 * 		currentView.removeEventListener( IOErrorEvent.IO_ERROR , onContentLoadError );		 * 		// Display a proper error message here, and go back to the previous route		 * 		sendNotification( RouteMachine.CANCEL );		 * }		 * </pre></listing>		 * 		 * @see #INTERRUPT		An example of interruption handling.		 */		public static const CANCEL			: String = NAME + "/note/cancel";				/**		 * Call this to continue a "paused" transition.		 * 		 * @see #INTERRUPT		An example of how to use interruption handling.		 * @see #CANCEL			An example of how to <i>abort</i> a transition.		 */		public static const CONTINUE		: String = NAME + "/note/continue";				/**		 * Called when trying to go to a Route that doesn't exist.		 * 		 * Mostly used by RouteMachine plugins like the <code>SWFAddressMediator</code>		 * 		 * @see SWFAddressMediator			Example usage of this notification.		 */		public static const INVALID			: String = NAME + "/note/invalid";				public static const ENTERING 		: String = NAME + "/note/entering";		public static const EXITING 		: String = NAME + "/note/exiting";		public static const CHANGED 		: String = NAME + "/note/changed";		private var _currentRoute 			: Route;		private var _currentLocation 		: String;		private var _cached 				: Array = new Array( );				private var _inTransition 			: Boolean;		private var _interrupted 			: Boolean;		private var _skipEnter 				: Boolean;		private var _skipExit 				: Boolean;		private var _continueData 			: Object;		private var _continueRoute 			: Route;		
		public function RouteMachine( routeClass : Class ) {			super( NAME, extractRoutes( routeClass ) );		}		private function extractRoutes( routeClass : Class ) : Array {			var desc : XML = describeType( routeClass );			var routes : Array = [];			for each( var state : XML in desc.constant )				routes.push( new Route( routeClass[state.@name] ) );			return routes;		}		override public function listNotificationInterests() : Array {			return [ RouteMachine.GOTO , RouteMachine.INTERRUPT , RouteMachine.CANCEL , RouteMachine.CONTINUE ];		}		override public function handleNotification(notification : INotification) : void {			switch( notification.getName( ) ) {				case RouteMachine.GOTO:					if( _inTransition ) return;					var route : Route = getMatchingRoute( notification.getType( ) );					var data : Object = notification.getBody() || route.defaultData;					if( DEBUG ) DEBUG_LOG( "RouteMachine#GOTO " + notification.getType() , _continueRoute );					transitionTo( route , data );					break;				case RouteMachine.INTERRUPT:					if( DEBUG ) DEBUG_LOG( "RouteMachine#INTERRUPT" );					_interrupted = true;					break;				case RouteMachine.CANCEL:					if( DEBUG ) DEBUG_LOG( "RouteMachine#CANCEL" );					reset();					// TODO Should this be going back to it's previous state, only on exit? or also on enter?//					if( _skipExit && !_skipEnter )//						sendNotification( RouteMachine.GOTO, body, type)					break;				case RouteMachine.CONTINUE:					if( DEBUG ) DEBUG_LOG( "RouteMachine#CONTINUE " + ( ( _skipEnter ) ? "(from enter)" : ( _skipExit ) ? "(from exit)" : "error" ) , _continueRoute );					if( !_inTransition ) 						throw new Error( "Need to cancel before continuing. Use GOTO instead." );					transitionTo( _continueRoute, _continueData );					break;			}		}				/**		 * Makes the RouteMachine as good as new. 		 * And now the GOTO may be called again...		 */		private function reset() : void {			_interrupted = false;			_continueRoute = null;			_continueData = null;			_skipEnter = _skipExit = false;			_inTransition = false;		}		protected function transitionTo( nextRoute : Route , data : Object ) : void {			if( !nextRoute ) {				if( DEBUG ) DEBUG_LOG( "RouteMachine#INVALID" );				sendNotification( RouteMachine.INVALID );				return;			}						var nextLocation : String = fixLocation( nextRoute.injectData( data ) );						// Same location means it's the same, so skip it.			if( _currentLocation && _currentLocation == nextLocation ) {				reset(); // Allow it to try again...				if( DEBUG ) DEBUG_LOG( "RouteMachine#Skipping transition because it's the same as the current." ); 				return;			}						// Clear the interrupt flag			_interrupted = false;			_inTransition = true;							// Exit the current  			if( DEBUG ) DEBUG_LOG( "RouteMachine#EXITING " + nextLocation ); 			if( _currentRoute != null && !_skipExit )				facade.notifyObservers( new RouteNotification( RouteMachine.EXITING , _currentRoute , _currentLocation , nextRoute , nextLocation , data ) );			_skipExit = true;						// Check to see whether the transition has been canceled			if( _interrupted ) {				if( DEBUG ) DEBUG_LOG( "RouteMachine#INTERRUPTED (during exit)" );				_continueRoute = nextRoute;				_continueData = data;				return;			}						if( DEBUG ) DEBUG_LOG( "RouteMachine#ENTERING " + nextLocation ); 			// Enter the next			if( !_skipEnter )				facade.notifyObservers( new RouteNotification( RouteMachine.ENTERING , _currentRoute , _currentLocation , nextRoute , nextLocation , data ) );			_skipEnter = true;						// Check to see whether the transition has been canceled			if( _interrupted ) {				if( DEBUG ) DEBUG_LOG( "RouteMachine#INTERRUPTED (during enter)" );				_continueRoute = nextRoute;				_continueData = data;				return;			}						// Allow the route to be changed again.			reset();						// Save the current route			_currentRoute = nextRoute;			_currentLocation = nextLocation;						if( DEBUG ) DEBUG_LOG( "RouteMachine#CHANGED " + nextLocation ); 						// Send the notification configured to be sent when this specific state becomes current 			facade.notifyObservers( new RouteNotification( RouteMachine.CHANGED, _currentRoute , _currentLocation , nextRoute , nextLocation , data ) );		}						protected function getMatchingRoute( location : String ) : Route {			if( _cached[ location ] ) return _cached[ location ];			for each( var route : Route in routes ) 				if( route.isLocation( location ) )					return _cached[ location ] = route;			return null;		}		protected function get routes() : Array {			return viewComponent as Array;		}				/**		 * Make sure it's a valid location (starting and ending with /)		 */		private function fixLocation( location : String ) : String {			if( location.substr( 0, 1 ) != "/") location = "/" + location;			if( location.substr( -1, 1 ) != "/") location += "/";			return location;		}	}}
package se.publicclass.debug {	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.text.TextField;		/**	 * Provides information about the TextField below the 	 * mouse position.	 *  	 * @author Robert Sk√∂ld, robert(at)publicclass.se	 */	public class TextInfo extends Sprite {		private var _metric : MetricWindow;		private var _info : InfoWindow;		public function TextInfo() {			addEventListener( Event.ADDED_TO_STAGE, onAddedToStage );		}		private function onAddedToStage(event : Event) : void {			_info = new InfoWindow( );			addChild( _info );			_metric = new MetricWindow( );			addChild( _metric );			removeEventListener( Event.ADDED_TO_STAGE, onAddedToStage );			stage.addEventListener( MouseEvent.MOUSE_MOVE, onMouseMove );		}		private function onMouseMove(event : MouseEvent) : void {			_info.update( event.target as TextField , event.localX , event.localY );			_metric.update( event.target as TextField , event.localX , event.localY );		}	}}import se.publicclass.utils.TextUtil;import flash.display.DisplayObject;import flash.display.Sprite;import flash.geom.Rectangle;import flash.text.StyleSheet;import flash.text.TextField;import flash.text.TextLineMetrics;import flash.utils.getQualifiedClassName;class InfoWindow extends Sprite {	private var _text : TextField;		// TODO Draw a frame with the information next to the currently active	//		TextField. If it's outside the stage, show it on the other side 	//		of the TextField.	public function InfoWindow() {		var css : StyleSheet = new StyleSheet();		css.setStyle( "body" , { 			fontFamily: "Helvetica, Verdana, _sans", 			fontSize: 12		} );		css.setStyle( "h1" , {			fontSize: 14		} );		_text = new TextField();		_text.autoSize = "left";		_text.styleSheet = css;		_text.width = 500;		_text.multiline = true;		_text.wordWrap = true;		_text.embedFonts = false;		addChild( _text ).y = 0;	}		private function getTextFieldPath( tf : TextField ) : String {		var path : String = "";		var obj : DisplayObject = tf;		while( obj != null ) {			path = obj.name + "/" + path;			obj = obj.parent;			if( !obj.parent ) break;		}		return path; 	}	public function update( tf : TextField ,  x : int , y : int ) : void {		visible = tf != null;		if( !tf ) return;				var currentCharIndex : int = tf.getCharIndexAtPoint( x, y );		if( currentCharIndex < 0 ) return;				var lineIndex : int = tf.getLineIndexOfChar( currentCharIndex );//		var lineLength : int = ( lineIndex > -1 ) ? tf.getLineLength( lineIndex ) : 0;		var firstParagraphCharIndex : int = tf.getFirstCharInParagraph( currentCharIndex );		var tfBounds : Rectangle = tf.getBounds( parent.parent );		var charBoundaries : Rectangle = tf.getCharBoundaries( currentCharIndex );		if( charBoundaries ) {			charBoundaries.x += tfBounds.x;			charBoundaries.y += tfBounds.y;		}		var firstParagraphCharBoundaries : Rectangle = tf.getCharBoundaries( firstParagraphCharIndex );		if( firstParagraphCharBoundaries ) {			firstParagraphCharBoundaries.x += tfBounds.x;			firstParagraphCharBoundaries.y += tfBounds.y;		}				var txt : String = "<body><h1>" + getTextFieldPath( tf ) + "</h1>";		txt += "\n" + TextUtil.toString( tf.getTextFormat( currentCharIndex ) );		txt += "\n" + tf.htmlText;		txt += "\nwidth: " + tf.width + ", height:" + tf.height + ", textWidth:" + tf.textWidth + ", textHeight:" + tf.textHeight;		txt += "\nrect (from parent): " + tf.getRect( tf.parent ) + ", bounds (from parent): " + tf.getBounds( tf.parent );		if( "getPreciseRect" in tf ) txt += ", preciseRect: " + Object( tf ).getPreciseRect( parent.parent );				_text.htmlText = txt;		_text.x = tf.x + tf.width;		if( _text.x + _text.width > tf.stage.stageWidth ) _text.x = tf.stage.stageWidth - _text.width;		_text.y = tf.y;	}		private function drawRect( rect : Rectangle , color : uint ) : void {		if( !rect ) return;		graphics.beginFill( color , .3 );		graphics.drawRect( rect.x , rect.y , rect.width, rect.height );		graphics.endFill();	}}class MetricWindow extends Sprite {	// TODO Draw a frame with the information next to the currently active	//		TextField. If it's outside the stage, show it on the other side 	//		of the TextField.	public function MetricWindow() {			}	public function update( tf : TextField ,  x : int , y : int ) : void {		visible = tf != null;		if( !tf ) return;				var currentCharIndex : int = tf.getCharIndexAtPoint( x, y );		if( currentCharIndex < 0 ) return;				var lineIndex : int = tf.getLineIndexOfChar( currentCharIndex );//		var lineLength : int = ( lineIndex > -1 ) ? tf.getLineLength( lineIndex ) : 0;		var firstParagraphCharIndex : int = tf.getFirstCharInParagraph( currentCharIndex );		var tfBounds : Rectangle = tf.getBounds( parent.parent );		var charBoundaries : Rectangle = tf.getCharBoundaries( currentCharIndex );		if( charBoundaries ) {			charBoundaries.x += tfBounds.x;			charBoundaries.y += tfBounds.y;		}		var firstParagraphCharBoundaries : Rectangle = tf.getCharBoundaries( firstParagraphCharIndex );		if( firstParagraphCharBoundaries ) {			firstParagraphCharBoundaries.x += tfBounds.x;			firstParagraphCharBoundaries.y += tfBounds.y;		}				var paragraphLength : int = tf.getParagraphLength( firstParagraphCharIndex );		var lastParagraphCharIndex : int = firstParagraphCharIndex + paragraphLength;				var lineMetrics : TextLineMetrics = tf.getLineMetrics(lineIndex );		var lineRect : Rectangle = new Rectangle( lineMetrics.x, charBoundaries.y + lineMetrics.descent, lineMetrics.width, lineMetrics.height );				graphics.clear();		// Draw the TextField bounds using a green color		drawRect( tfBounds , 0x00FF00 );				// Draw the current character using a red color		drawRect( charBoundaries , 0xFF0000 );				// Draw the first paragraph character using a blue color		drawRect( firstParagraphCharBoundaries , 0x0000FF );				// Draw the current line using a yellow color		drawRect( lineRect , 0x00FFFF );				// Draw the precise rect (if it has it) using a yellow color		if( "getPreciseRect" in tf ) {			var precise : Rectangle = Object( tf ).getPreciseRect( parent.parent ) as Rectangle;			drawRect( precise , 0xFFFF00 );					}				// Draw the current paragraph using a cyan color		for( var char : int = firstParagraphCharIndex; char < lastParagraphCharIndex; char++ ) {			var paragraphCharBoundaries : Rectangle = tf.getCharBoundaries( char );			if( paragraphCharBoundaries ) {				paragraphCharBoundaries.x += tfBounds.x;				paragraphCharBoundaries.y += tfBounds.y;				drawRect( paragraphCharBoundaries , 0xFF00FF );			}		}			}		private function drawRect( rect : Rectangle , color : uint ) : void {		if( !rect ) return;		graphics.beginFill( color , .3 );		graphics.drawRect( rect.x , rect.y , rect.width, rect.height );		graphics.endFill();	}}
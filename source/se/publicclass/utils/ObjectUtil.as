package se.publicclass.utils {	import flash.utils.ByteArray;import flash.utils.describeType;			
	/**	 * @author Robert Sk√∂ld	 */	public class ObjectUtil {		/**		 * Merges the values and keys from two objects.		 * If the two objects have the same property, it's obj2's property that "wins" (it has higher priority).		 * Only merged enumerable properties.		 * 		 * TODO Maybe we can merge ALL properties if we parse it using describeType		 * 		 * @param obj1 		An object which properties will be merged with obj2. (lower priority).		 * @param obj2 		An object which properties will be merged with obj1. (higher priority).		 * 		 * @return 			A new object with the properties of obj1 and obj2.		 */		public static function merge( obj1 : Object , obj2 : Object ) : Object {			var obj : Object = new Object( );			var key : String;			for( key in obj1 ) obj[ key ] = obj1[ key ];			for( key in obj2 ) obj[ key ] = obj2[ key ];			return obj;		}				/**		 * Checks if an object doesn't contain any properties.		 */		public static function isEmpty( obj : Object ) : Boolean {			for( var a : String in obj ) return false;			return true;		}				public static function equals( obj1 : Object , obj2 : Object ) : Boolean {			if( obj1 === obj2 ) return true;						var key : String;			var count1 : int = 0, count2 : int = 0;			for( key in obj1 ) {				if( obj1[key] != obj2[key ] )					return false;				count1++;			}								for( key in obj2 ) {				if( obj1[key] != obj2[key ] )					return false;				count2++;			}						return count1 == count2;		}				/**		 * Clones an object using a ByteArray.		 * Won't work with DisplayObjects. It will also not work for anything that needs to keep 		 * references to specific instances, such as listener arrays, as everything gets copied afresh.		 */		public static function clone( o : Object ) : Object {			var bytes : ByteArray = new ByteArray( );			bytes.writeObject( o );			bytes.position = 0;			return bytes.readObject( );		}	}}